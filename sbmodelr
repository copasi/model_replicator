#!/usr/bin/python3
#
# sbmodelr
# Model Replicator
#
# This takes a SBML or .cps file and replicates it as a set of sub-models
# which can exist just side-by-side or can be connected in different ways.
#
# Written March-April 2024 by Pedro Mendes <pmendes@uchc.edu>
# this code is released under the Artistic 2.0 License

__version__ = "1.0a2"

import os
import re
import sys
import argparse
import shlex
import time
from datetime import date, datetime

import pandas as pd
from basico import *

#######################
# AUXILIARY FUNCTIONS #

# function to test if string has a number, it's amazing this is not native to python...
def is_float(string):
    try:
        float(string)
        return True
    except ValueError:
        return False

# function to check if a string is an element in the model
def is_element(candidate):
    el=False
    if( (seednparams>0) and (candidate in mparams.index) ):
        el=True
    else:
        if( (seedncomps>0) and (candidate in mcomps.index) ):
            el=True
        else:
            if( (seednspecs>0) and (candidate in mspecs.index) ):
                el=True
            else:
                if( (seednreacts>0) and (candidate in mreacts.index) ):
                    el=True
    return el

# function to add a diffusive term to an ode expression
def add_diffusive_term(expression, c, a, b):
    return expression + f' + Values[{c}] * ( {a} - {b} )'

# function to add an irreversible diffusive term to an ode expression
def add_irr_diffusive_term(expression, c, sign, a):
    return expression + f' {sign} Values[{c}] * {a}'

# function to change expression fixing all references to element names with the appropriate suffix
def fix_expression(exp, suff):
    expression = str(exp)
    #is the full expression an element?
    if( is_element(expression) ):
        # just process it and return
        expression = expression + suff
        return expression
    mname = re.findall(r'^CN=Root,Model=(.+?),', expression )
    if( mname ):
        expression = re.sub(r'^CN=Root,Model=(.+?),', f'CN=Root,Model={newname},', expression )
    # find object names inside []
    evars = re.findall(r'\[(.+?)\]', expression )
    if( evars ):
        for el in evars:
            #check that the variable exists
            if( is_element(el) ):
                elnew = el + suff
                expression = re.sub(fr'\[{el}\]', f'[{elnew}]', expression )
    # find object names inside ()
    evars = re.findall(r'\((.+?)\)', expression )
    if( evars ):
        for el in evars:
            #check that the variable exists
            if( is_element(el) ):
                elnew = el + suff
                expression = re.sub(fr'\({el}\)', f'({elnew})', expression )
    # find object names inside () special case of ( something(else) )
    evars = re.findall(r'\((.*\(.*\).*?)\)', expression )
    if( evars ):
        for el in evars:
            #check that the variable exists
            if( is_element(el) ):
                elnew = el + suff
                el = re.sub(r'\(', r'\\(', el)
                el = re.sub(r'\)', r'\\)', el)
                expression = re.sub(el,elnew, expression )
    # find object names like R1.Rate, I2.InitialParticleNumber, etc.
    evars = re.findall(r'([^\s\]\)]+?)\.\w', expression )
    if( evars ):
        for el in evars:
            #check that the variable exists
            if( is_element(el) ):
                elnew = el + suff
                expression = re.sub(fr'{el}\.(\w)', f'{elnew}.\1', expression )
    return expression

# function to check that value is positive, helper for argparse
def positive_integer(value):
    ivalue = int(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError("%s is an invalid negative value" % value)
    return ivalue

# function to check that value is positive, helper for argparse
def positive_float(value):
    ivalue = float(value)
    if ivalue <= 0:
        raise argparse.ArgumentTypeError("%s is an invalid negative value" % value)
    return ivalue

# function to load and parse a graphviz network file, return list of links as tuples
def read_network(network_file):
    # read file
    with open(network_file) as f:
        netf = f.read()
    # create list for links
    ll = []
    # check if this is a digraph
    if( re.search(r'digraph\s*.*{', netf) ):
        ll.append((0,0))
        # print( f' Warning: {network_file} contains a directed graph, however connections will be made reversible' )
    # check for the odd case of /* and */ appearing inside separate quotes and refuse to parse
    if( re.search(r'"[\s\S]*?\/\*[\s\S]*\*\/[\s\S]*?"', netf) ):
        print(fr'{network_file} contains identifiers with \* and *\, and cannot be parsed')
        return []
    # remove comments
    netf = re.sub(r'\s*//.*', '', netf)          # // comments
    netf = re.sub(r'\s*#.*', '', netf)           # # comments
    netf = re.sub(r'\/\*[\s\S]*?\*\/', '', netf) # /* */ comments
    # find all simple connections like 1--2 and 1--2--3
    # make sure that comments are ignored
    matches = re.findall( r'"*(\d+)"*(?:\:\w+)*\s*(?=(-[-|>]\s*"*(?:\d+)"*(?:\:\w+)*))', netf)
    if( matches ):
        for match in matches:
            e1 = int(match[0])
            se = re.search(r'(\d+)',match[1])
            if( se is None ):
                print(f' Warning: {network_file} contains invalid node {match[1]}, no connections added')
                return []
            e2 = int(se.group(1))
            if( e1 == e2 ):
                print(f' Warning: self-connections not allowed, ignoring {e1} -> {e2}')
            else:
                if( (e1,e2) not in ll):
                    ll.append((e1,e2))
                else:
                    print(f' Warning: duplicate entry for connection {e1} to {e2}, ignored')
    # find connections to groups
    gmatches = re.findall( r'"*(\d+)"*(?:\:\w+)*\s*-[-|>]\s*(\{[\d\s;,"]+\})', netf)
    if( gmatches ):
        for gmatch in gmatches:
            e1 = int(gmatch[0])
            se = re.findall(r'(\d+)',gmatch[1])
            if( se is None ):
                print(f' Warning: {network_file} contains invalid group node {gmatch[1]}, no connections added')
                return []
            for s in se:
                e2 = int(s)
                if( e1 == e2 ):
                    print(f' Warning: self-connections not allowed, ignoring {e1} -> {e2}')
                else:
                    if( (e1,e2) not in ll):
                        ll.append((e1,e2))
                    else:
                        print(f' Warning: duplicate entry for connection {e1} to {e2}, ignored')
    # check if list is empty and issue warning
    if( (len(ll) == 0) or ( (len(ll) == 1) and ll[0] == (0,0) ) ):
        print(f' Warning: {network_file} did not contain any valid edges, no connections added')
        if( len(ll) == 1 ):
            del ll[0]
    return ll

############################
# MAIN PROGRAM STARTS HERE #

############
# Strategy:
#  1. parse command line and deal with options
#  2. read original model,
#  3. copy notes, annotations, and units
#  4. create new model
#  MAIN LOOP, iterating over each model element:
#   5. create parameters, compartments, species without expressions
#      TODO: what to do with element annotations?
#   6. create reactions (and fix mappings)
#   7. set expressions for compartments and species
#   8. create events that depende on variable
#   9. loop over remaining events that don't depend on variables
#  10. create medium unit if needed
#  11. create unit connections
#  12. copy task settings
#  13. save model
#  TODO: add Michaelis-Menten transport
############


#####
#  1. parsing the command line
#####

parser = argparse.ArgumentParser(
                    prog='sbmodelr',
                    description='Convert one SBML/COPASI model into another one containing many replicas of the original.')
# arguments
parser.add_argument('filename', help='original model file')
parser.add_argument('rows', type=positive_integer, default=2,
                    help='total number of units or number of rows in a 2D or 3D grid')
parser.add_argument('columns', nargs='?', type=positive_integer, default=1,
                    help='number of columns in a 2D or 3D grid')
parser.add_argument('layers', nargs='?', type=positive_integer, default=1,
                    help='number of layers in a 3D grid')
parser.add_argument('-V', '--version', action='version', version=f'sbmodelr {__version__}')
parser.add_argument('-q', '--quiet', action='store_true', help='supress information messages')
parser.add_argument('-t', '--transport', action='append', help='species to be transported between units')
parser.add_argument('-r', '--transport-rate', type=positive_float, help='rate constant for transport between units')
parser.add_argument('-o', '--ode-coupling', action='append', help='explicit ODE to be coupled between units by diffusive terms')
parser.add_argument('-s', '--ode-synaptic', action='append', help='explicit ODE to be coupled between units by chemical synaptic terms')
parser.add_argument('-c', '--coupling-constant', type=float, help='strength of ODE coupling between units')
parser.add_argument('-n', '--network', help='graphviz network file for unit connections')
parser.add_argument('--add-medium', action='store_true', help='add a medium unit with the transported species')
parser.add_argument('--ignore-tasks', action='store_true', help='do not copy over task settings')
parser.add_argument('--sbml', choices=['l1v2', 'l2v3', 'l2v4', 'l3v1', 'l3v2'], help='export in sbml of this level and version.')

# Parse the arguments
args = parser.parse_args()

seedmodelfile = args.filename
r = args.rows
c = args.columns
l = args.layers

# default value for transport rates
trate = 1.0
if( args.transport_rate ):
    trate = args.transport_rate

# default value for ODE coupling constants
coupleconst = 1.0
if( args.coupling_constant ):
    coupleconst = args.coupling_constant

# default constants for ode synaptic connections
# TODO: these should be allowed to be passed through command line
taurinit = 0.5
taudinit = 8
v0init = 5
vsyninit = 20
gcinit = 1

# unify the lists of ODEs to couple
odelink = []
if( args.ode_coupling ):
    for ode in args.ode_coupling:
        # 'd' means diffusive coupling
        odelink.append((ode,'d'))
if( args.ode_synaptic ):
    for ode in args.ode_synaptic:
        # 's' means synaptic coupling
        odelink.append((ode,'s'))

# get the base of the filename
base,ext = os.path.splitext(seedmodelfile)

if( ext.lower() != '.cps' ):
    args.ignore_tasks = True

# set sbml level and version (l2v4 is the default)
sbmll = 2
sbmlv = 4
if( args.sbml ):
    slv = re.match( r'l(\d)v(\d)', args.sbml )
    if( slv ):
        sbmll = int(slv.group(1))
        sbmlv = int(slv.group(2))

# sanity check
nmodels = r*c*l

if(nmodels==1):
    print("ERROR: Nothing to do, one copy only is the same as the original model!\nAt least one of rows, columns or layers must be larger than 1.\n")
    exit()

# check dimensionality
dim=0
if(r>1):
    dim = dim + 1
if(c>1):
    dim = dim + 1
if(l>1):
    dim = dim + 1

# strings to add to comments and titles, etc
if(dim==1):
    fsuff = f"{nmodels}"
    desc = f"a set of {nmodels} replicas"
    apdx1 = '_1'
    gridr = nmodels
    gridc = 1
    gridl = 1
else:
    if(dim==3):
        gridr = r
        gridc = c
        gridl = l
        fsuff = f"{gridr}x{gridc}x{gridl}"
        desc = f"a 3D set of {nmodels} replicas ({gridr}x{gridc}x{gridl})"
        apdx1 = '_1,1,1'
    else:
        if(r==1):
            gridr = c
            gridc = l
            gridl = 1
            fsuff = f"{gridr}x{gridc}"
            desc = f"a 2D set of {nmodels} replicas ({gridr}x{gridc})"
            apdx1 = '_1,1'
        else:
            if(c==1):
                gridr = r
                gridc = l
                gridl = 1
                fsuff = f"{gridr}x{gridc}"
                desc = f"a 2D set of {nmodels} replicas ({gridr}x{gridc})"
                apdx1 = '_1,1'
            else:
                gridr = r
                gridc = c
                gridl = 1
                fsuff = f"{gridr}x{gridc}"
                desc = f"a 2D set of {nmodels} replicas ({gridr}x{gridc})"
                apdx1 = '_1,1'

# parse the network file if needed
if( args.network ):
    # check dimension
    if( dim > 1 ):
        print(f'ERROR: network file is only relevant for dimension 1 but you chose dimension {dim} ({fsuff})')
        exit()
    # parse the network file
    links = read_network(args.network)
    digraph = False
    if( len(links) > 0 ):
        if( links[0]==(0,0) ):
            digraph = True
            del links[0]
        for link in links:
            # sanity check
            if( (link[0] < 1) or (link[1] < 1) or (link[0] > nmodels) or (link[1] > nmodels) ):
                print(f'ERROR: network file lists nodes with numbers outside [1,{nmodels}]')
                exit()

#####
#  2. read the original model
#####

seedmodel = load_model(seedmodelfile, remove_user_defined_functions=True)
if( seedmodel is None):
    print(f'ERROR: {seedmodelfile} failed to load.\n')
    exit()

# print some information about the model
if( not args.quiet ):
    print(f'Processing {seedmodelfile}')

#Get the global quantities
mparams = get_parameters(model=seedmodel, exact=True)
if( mparams is None):
    seednparams = 0
    pfixed = 0
    passg = 0
    pode = 0
else:
    seednparams = mparams.shape[0]
    # count subsets (fixed, assignment, ode)
    pfixed = (mparams['type']=='fixed').sum()
    passg = (mparams['type']=='assignment').sum()
    pode = (mparams['type']=='ode').sum()

#Get the compartments
mcomps = get_compartments(model=seedmodel, exact=True)
if( mcomps is None):
    seedncomps = 0
    cfixed = 0
    cassg = 0
    code = 0
else:
    seedncomps = mcomps.shape[0]
    # count subsets (fixed, assignment, ode)
    cfixed = (mcomps['type']=='fixed').sum()
    cassg = (mcomps['type']=='assignment').sum()
    code = (mcomps['type']=='ode').sum()
    #print(mcomps)

#Get the species
mspecs = get_species(model=seedmodel, exact=True)
if( mspecs is None):
    seednspecs = 0
    sreact = 0
    sfixed = 0
    sassg = 0
    sode = 0
else:
    seednspecs = mspecs.shape[0]
    # count subsets (fixed, assignment, ode)
    sreact = (mspecs['type']=='reactions').sum()
    sfixed = (mspecs['type']=='fixed').sum()
    sassg = (mspecs['type']=='assignment').sum()
    sode = (mspecs['type']=='ode').sum()
    #print(mspecs)

# get the reactions
mreacts = get_reactions(model=seedmodel, exact=True)
#print(mreacts)
if( mreacts is None):
    seednreacts = 0
else:
    seednreacts = mreacts.shape[0]

# get the events
mevents = get_events(model=seedmodel, exact=True)
if( mevents is None):
    seednevents = 0
else:
    seednevents = mevents.shape[0]
#for m in mevents.index:
#    print(mevents.loc[m,'trigger'])

# print summary of model elements
if( not args.quiet ):
    print(f"  Reactions:         {seednreacts}")
    print(f"  Species:           {seednspecs}\t(Reactions: {sreact}, Fixed: {sfixed}, Assignment: {sassg}, ODE: {sode})")
    print(f"  Compartments:      {seedncomps}\t(Fixed: {cfixed}, Assignment: {cassg}, ODE: {code})")
    print(f"  Global quantities: {seednparams}\t(Fixed: {pfixed}, Assignment: {passg}, ODE: {pode})")
    # we print the events later to be able to show how many are only time dependent

# read scan items
# we need to retrieve then now before we create a new model due to a bug in COPASI/BasiCO (not sure which)
scanitems = get_scan_items(model=seedmodel)

#####
#  3. copy notes, annotations, and units
#####

seedname = get_model_name(model=seedmodel)

# edit the notes
nnotes = get_notes(model=seedmodel)
# check if notes are empty
if not nnotes:
    nnotes = f"<body xmlns=\"http://www.w3.org/1999/xhtml\"><p><br/></p><hr/><p>Processed with sbmodelr to produce {desc} of {seedmodelfile}</p></body>"
else:
    # check if the notes are in HTML
    index = nnotes.find('</body>')
    if( index == -1 ):
        # not HTML, so add a simple string
        nnotes = nnotes + f"\n\nProcessed with sbmodelr to produce {desc} of {seedmodelfile}"
    else:
        # add info at the end of the body section
        nend = nnotes[index:]
        nnotes = nnotes[:index] + f"<hr/><p>Processed with sbmodelr to produce {desc} of {seedmodelfile}</p>" + nend

# get original model units
munits = get_model_units(model=seedmodel)

#####
#  4. create new model
#####

# create new model filename (if sbml string was given force .xml extension)
if( args.sbml ):
    newfilename = f"{base}_{fsuff}.xml"
else:
    newfilename = f"{base}_{fsuff}{ext}"

# create the new model name
newname = f"{desc} of {seedname}"

# create the new model
newmodel = new_model(name=newname,
                     notes=nnotes,
                     quantity_unit=munits['quantity_unit'],
                     time_unit=munits['time_unit'],
                     volume_unit=munits['volume_unit'],
                     area_unit=munits['area_unit'],
                     length_unit=munits['length_unit'])

# set the intial time
it= get_value('Time', initial=True, model=seedmodel)
set_value('Time', it, initial=True, model=newmodel)

# transfer the annotations
miriam = get_miriam_annotation(model=seedmodel)
if 'created' in miriam:
    set_miriam_annotation(model=newmodel, created=miriam['created'], replace=True)
if 'creators' in miriam:
    set_miriam_annotation(model=newmodel, creators=miriam['creators'], replace=True)
if 'references' in miriam:
    set_miriam_annotation(model=newmodel, references=miriam['references'], replace=True)
if 'description' in miriam:
    set_miriam_annotation(model=newmodel, description=miriam['description'], replace=True)
# add one modification now
if 'modifications' in miriam:
    miriam['modifications'].append(datetime.datetime.now())
    set_miriam_annotation(model=newmodel, modifications=miriam['modifications'], replace=True)
else:
    modf = []
    modf.append(datetime.datetime.now())
    set_miriam_annotation(model=newmodel, modifications=modf, replace=True)

#####
#  MAIN LOOP FOR REPLICATION
#####

# we use "_i" as suffix for 1D, "_r,c" for 2D and "_r,c,l" for 3D
i = 0
for r in range(gridr):
    for c in range(gridc):
        for l in range(gridl):
            if(dim==1):
                apdx = f"_{i+1}"
            else:
                if(dim==2):
                    apdx = f"_{r+1},{c+1}"
                else:
                    apdx = f"_{r+1},{c+1},{l+1}"

#####
#  5. create parameters, compartments and species
#####
            # PARAMETERS
            if( seednparams>0 ):
                for p in mparams.index:
                    nname = p + apdx
                    add_parameter(model=newmodel, name=nname, status='fixed', initial_value=mparams.loc[p].at['initial_value'], unit=mparams.loc[p].at['unit'] )
            if( seedncomps > 0):
                for p in mcomps.index:
                    nname = p + apdx
                    add_compartment(model=newmodel, name=nname, status=mcomps.loc[p].at['type'], initial_size=mcomps.loc[p].at['initial_size'], unit=mcomps.loc[p].at['unit'], dimiensionality=mcomps.loc[p].at['dimensionality'] )
            if( seednspecs > 0):
                for p in mspecs.index:
                    nname = p + apdx
                    cp = mspecs.loc[p].at['compartment'] + apdx
                    add_species(model=newmodel, name=nname, compartment_name=cp, status=mspecs.loc[p].at['type'], initial_concentration=mspecs.loc[p].at['initial_concentration'], unit=mspecs.loc[p].at['unit'] )

#####
#  6. create reactions
#####

            # REACTIONS
            if( seednreacts > 0):
                for p in mreacts.index:
                    nname = p + apdx
                    scheme = mreacts.loc[p].at['scheme']
                    tok = scheme.split(';')
                    #tok2 = [sub.split() for sub in tok]
                    tok2 = [shlex.split(sub, posix=False) for sub in tok]
                    # build the reaction string
                    rs = ""
                    for t in tok2[0]:
                        if( (t == '=') or (t == '->') or (t == '+') or is_float(t) or (t=="*")):
                            rs = rs + t + " "
                        else:
                            if re.match(r'\".+\"', t):
                                t = re.sub( r'\"(.+)\"', f'"\\1{apdx}"', t )
                                rs = rs + t + " "
                            else:
                                rs = rs + t + apdx + " "
                    if( len(tok2) > 1 ):
                        # deal with the modifiers
                        rs = rs[:len(rs)-1] + "; "
                        for t in tok2[1]:
                            if re.match(r'\".+\"', t):
                                t = re.sub( r'\"(.+)\"', f'"\\1{apdx}"', t )
                                rs = rs + t + " "
                            else:
                                rs = rs + t + apdx + " "
                    # fix the parameter mappings
                    mapp = mreacts.loc[p].at['mapping'].copy()
                    for key in mapp:
                        if( isinstance(mapp[key], str) ):
                            t = mapp[key]
                            if re.match(r'\".+\"', t):
                                t = re.sub( r'\"(.+)\"', f'"\\1{apdx}"', t )
                            else:
                                t = t + apdx
                            mapp[key] = t
                        else:
                            if( isinstance(mapp[key], list ) ):
                                nmk = []
                                for k2 in mapp[key]:
                                    if re.match(r'\".+\"', k2):
                                        k2 = re.sub( r'\"(.+)\"', f'"\\1{apdx}"', k2 )
                                    else:
                                        k2 = k2 + apdx
                                    nmk.append(k2)
                                mapp[key] = nmk
                                #mapp[key] = [k2 + apdx for k2 in mapp[key]]
                    add_reaction(model=newmodel, name=nname, scheme=rs, mapping=mapp, function=mreacts.loc[p].at['function'] )

#####
#  7. set expressions and initial_expressions
#####

            # PARAMETERS
            if( seednparams > 0 ):
                for p in mparams.index:
                    nname = p + apdx
                    if( mparams.loc[p].at['initial_expression'] ):
                        ie = fix_expression(mparams.loc[p].at['initial_expression'], apdx)
                        set_parameters(model=newmodel, name=nname, exact=True, initial_expression=ie )
                    if( mparams.loc[p].at['type']=='assignment' or mparams.loc[p].at['type']=='ode'):
                        ex = fix_expression(mparams.loc[p].at['expression'], apdx)
                        set_parameters(model=newmodel, name=nname, exact=True, status=mparams.loc[p].at['type'], expression=ex )
            # COMPARTMENTS
            if( seedncomps > 0):
                for p in mcomps.index:
                    nname = p + apdx
                    if( mcomps.loc[p].at['initial_expression'] ):
                        ie = fix_expression(mcomps.loc[p].at['initial_expression'], apdx)
                        set_compartment(model=newmodel, name=nname, exact=True, initial_expression=ie )
                    if( mcomps.loc[p].at['type']=='assignment' or mcomps.loc[p].at['type']=='ode'):
                        ex = fix_expression(mcomps.loc[p].at['expression'], apdx)
                        set_compartment(model=newmodel, name=nname, exact=True, expression=ex )
            # SPECIES
            if( seednspecs > 0):
                for p in mspecs.index:
                    nname = p + apdx
                    cp = mspecs.loc[p].at['compartment'] + apdx
                    if( mspecs.loc[p].at['initial_expression'] ):
                        ie = fix_expression(mspecs.loc[p].at['initial_expression'], apdx)
                        set_species(model=newmodel, name=nname, exact=True, initial_expression=ie )
                    if( mspecs.loc[p].at['type']=='assignment' or mspecs.loc[p].at['type']=='ode'):
                        ex = fix_expression(mspecs.loc[p].at['expression'], apdx)
                        set_species(model=newmodel, name=nname, exact=True, expression=ex )

#####
#  8. create events
#####

            # EVENTS
            timeonlyevents = []
            if( seednevents > 0):
                for p in mevents.index:
                    # fix the trigger expression
                    tr = fix_expression(mevents.loc[p].at['trigger'], apdx)
                    # we skip events that have no elements in the trigger (time-dependent only)
                    if(tr != mevents.loc[p].at['trigger']):
                        # fix name
                        nm = p + apdx
                        # process the targets and expressions
                        assg = []
                        for a in mevents.loc[p].at['assignments']:
                            assg.append((fix_expression(a['target'],apdx),  fix_expression(a['expression'],apdx)))
                        # add the event
                        add_event(model=newmodel, name=nm, trigger=tr, assignments=assg, delay=fix_expression(mevents.loc[p].at['delay'],apdx), priority=fix_expression(mevents.loc[p].at['priority'],apdx), persistent=mevents.loc[p].at['persistent'], fire_at_initial_time=mevents.loc[p].at['fire_at_initial_time'], delay_calculation=mevents.loc[p].at['delay_calculation'])
                    else:
                        # the trigger does not involve any model element other than time
                        # add it to the list to be dealt with later
                        timeonlyevents.append(p)

            i += 1

#####
#  9. create events not dependent on variables
#####

etd=len(timeonlyevents)
entd = seednevents - etd

# now we can print out the rest of the model information
if( not args.quiet ):
    #how many events there are...
    print(f"  Events:            {seednevents}\t(Only time-dependent: {etd}, variable-dependent: {entd})")
    # and also information on network if one is used
    if( args.network ):
        if digraph:
            netype = 'directed'
        else:
            netype = 'undirected'
        print(f"  Network:           {netype}\t(Nodes: {nmodels}, Edges: {len(links)})")

# let's go over the events again to process those that are only time dependent
if( etd > 0 ):
    # loop over the time-only dependent events
    for p in timeonlyevents:
        # if the delay or priority expressions contain elements we use model_1
        dl = fix_expression(mevents.loc[p].at['delay'],apdx1)
        pr = fix_expression(mevents.loc[p].at['priority'],apdx1)
        if( not args.quiet ):
            if( dl != mevents.loc[p].at['delay'] ):
                print(f' Warning: Event {p} contains a delay expression dependent on variables, it was set to the variables of unit {apdx1}')
            if( pr != mevents.loc[p].at['priority'] ):
                print(f' Warning: Event {p} contains a priority expression dependent on variables, it was set to the variables of unit {apdx1}')
        # process the targets and expressions
        assg = []
        for a in mevents.loc[p].at['assignments']:
            # now loop over all replicates to duplicate the targets
            i = 0
            for r in range(gridr):
                for c in range(gridc):
                    for l in range(gridl):
                        if(dim==1):
                            apdx = f"_{i+1}"
                        else:
                            if(dim==2):
                                apdx = f"_{r+1},{c+1}"
                            else:
                                apdx = f"_{r+1},{c+1},{l+1}"
                        # add the assignment
                        assg.append((fix_expression(a['target'],apdx), fix_expression(a['expression'],apdx)))
                        i = i + 1
        # add the event
        add_event(model=newmodel, name=p, trigger=mevents.loc[p].at['trigger'], assignments=assg, delay=dl, priority=pr, persistent=mevents.loc[p].at['persistent'], fire_at_initial_time=mevents.loc[p].at['fire_at_initial_time'], delay_calculation=mevents.loc[p].at['delay_calculation'])

#####
# 10. create medium unit if needed
#####
if( args.add_medium ):
    if( args.transport or odelink ):
        # check if there is no compartment called "medium
        medium_name = 'medium'
        if((mcomps is not None) and (medium_name in mcomps.index)):
            medium_name = '_added_medium_'
        # create medium compartment
        add_compartment(model=newmodel, name=medium_name, status='fixed', initial_size=1, dimiensionality=3 )
        # create the species that are transported
        if( args.transport ):
            for sp in args.transport:
                nname = f'{sp}_medium'
                add_species(model=newmodel, name=nname, compartment_name=medium_name, status='fixed', initial_concentration=mspecs.loc[sp].at['initial_concentration'], unit=mspecs.loc[sp].at['unit'] )
        # we should create odes here too, but it is easier to create them further down
        # because they can be of one of three different types of entity

    else:
        print(' Warning: no medium unit created because no species are being transported or ODEs coupled')


#####
# 11. create unit connections
#####

# species to be transported
if( args.transport ):
    for sp in args.transport:
        # check that the species exists
        if( (seednspecs>0) and (sp in mspecs.index) ):
            # check that the species depends on reactions
            if( mspecs.loc[sp].at['type'] != 'reactions' ):
                print( f'ERROR: {sp} is a species that does not depend on reactions, no transport reactions can be added')
                exit()
            # add a rate constant for the transport reactions
            rateconst = f'k_{sp}_transport'
            add_parameter(name=rateconst, initial_value=trate, model=newmodel)
            # add a transport reaction for each neighbour
            if( dim == 1):
                # add transport between species and the medium which is always reversible
                if(args.add_medium):
                    for r in range(gridr):
                        suffa = f'{r+1}'
                        rname = f't_{sp}_{suffa}-medium'
                        rscheme = f'{sp}_{suffa} = {sp}_medium'
                        rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_medium'}
                        add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
                if( args.network ):
                    for link in links:
                        suffa = f'{link[0]}'
                        suffb = f'{link[1]}'
                        rname = f't_{sp}_{suffa}-{suffb}'
                        rscheme = f'{sp}_{suffa} = {sp}_{suffb}'
                        # check whether reversible or irreversible
                        if digraph:
                            rmap = {'k1': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_{suffb}'}
                            add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (irreversible)' )
                        else:
                            rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_{suffb}'}
                            add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
            elif( dim == 2 ):
                for r in range(gridr):
                    for c in range(gridc):
                        suffa = f'{r+1},{c+1}'
                        if(args.add_medium):
                            rname = f't_{sp}_{suffa}-medium'
                            rscheme = f'{sp}_{suffa} = {sp}_medium'
                            rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_medium'}
                            add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
                        if( c+1 < gridc ):
                            suffb = f'{r+1},{c+2}'
                            rname = f't_{sp}_{suffa}-{suffb}'
                            rscheme = f'{sp}_{suffa} = {sp}_{suffb}'
                            rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_{suffb}'}
                            add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
                        if( r+1 < gridr ):
                            suffb = f'{r+2},{c+1}'
                            rname = f't_{sp}_{suffa}-{suffb}'
                            rscheme = f'{sp}_{suffa} = {sp}_{suffb}'
                            rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_{suffb}'}
                            add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
            elif( dim == 3 ):
                for r in range(gridr):
                    for c in range(gridc):
                        for l in range(gridl):
                            suffa = f'{r+1},{c+1},{l+1}'
                            rname = f't_{sp}_{suffa}-medium'
                            rscheme = f'{sp}_{suffa} = {sp}_medium'
                            rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_medium'}
                            add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
                            if( c+1 < gridc ):
                                suffb = f'{r+1},{c+2},{l+1}'
                                rname = f't_{sp}_{suffa}-{suffb}'
                                rscheme = f'{sp}_{suffa} = {sp}_{suffb}'
                                rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_{suffb}'}
                                add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
                            if( r+1 < gridr ):
                                suffb = f'{r+2},{c+1},{l+1}'
                                rname = f't_{sp}_{suffa}-{suffb}'
                                rscheme = f'{sp}_{suffa} = {sp}_{suffb}'
                                rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_{suffb}'}
                                add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
                            if( l+1 < gridl ):
                                suffb = f'{r+1},{c+1},{l+2}'
                                rname = f't_{sp}_{suffa}-{suffb}'
                                rscheme = f'{sp}_{suffa} = {sp}_{suffb}'
                                rmap = {'k1': rateconst, 'k2': rateconst, 'substrate': f'{sp}_{suffa}', 'product': f'{sp}_{suffb}'}
                                add_reaction(model=newmodel, name=rname, scheme=rscheme, mapping=rmap, function='Mass action (reversible)' )
            else:
                # insanity error
                print('ERROR: this should not happen, dim is not 1,2 or 3. Contact developer!')
                exit()
        else:
            # error
            print( f'ERROR: Species {sp} does not exist in the model, no transport reactions added' )
            exit()

# ODEs to be coupled by diffusive mechanism
if( odelink ):
    for (ode,linktype) in odelink:
        if( linktype=='d'):
            # add a rate constant for the diffusive connections
            diffconst = f'k_{ode}_coupling'
            add_parameter(diffconst, type='fixed', initial_value=coupleconst, model=newmodel)
        elif( linktype=='s'):
            # check dimension, only dim 1 can have synaptic connections
            if(dim>1):
                print(f'ERROR: 2D or 3D grids cannot have synaptic connections')
                exit()
            if( args.network and not digraph ):
                print( f' Warning: network was defined as undirected, but synapses will be added as directed connections' )
            # add rate constants for the synaptic connections
            syntaur = f'tau_r_{ode}_synapse'
            add_parameter(syntaur, type='fixed', initial_value=taurinit, model=newmodel)
            syntaud = f'tau_d_{ode}_synapse'
            add_parameter(syntaud, type='fixed', initial_value=taudinit, model=newmodel)
            synv0 = f'V0_{ode}_synapse'
            add_parameter(synv0, type='fixed', initial_value=v0init, model=newmodel)
            synvsyn = f'Vsyn_{ode}_synapse'
            add_parameter(synvsyn, type='fixed', initial_value=vsyninit, model=newmodel)
        else:
            print(f'ERROR: ODE link of type \'{linktype}\' is not allowed.')
            exit()
        # check if the global variable is an ODE
        if( (mparams is not None) and (ode in mparams.index) ):
            if( mparams.loc[ode].at['type'] != 'ode' ):
                print(f'ERROR: {ode} is a global variable that is not an ODE')
                exit()
            if( dim == 1):
                # add coupling between unit and the medium
                if(args.add_medium and linktype=='d'):
                    # we first need to add the global quantity
                    mediumode = f'{ode}_medium'
                    medexp = ''
                    add_parameter(mediumode, type='ode', expression=medexp, initial_value=mparams.loc[ode].at['initial_value'], model=newmodel)
                    for r in range(gridr):
                        # name of ode in this unit
                        suffa = f'{r+1}'
                        oname = f'{ode}_{suffa}'
                        # get ode to get expression
                        tode = get_parameters(oname, exact=True, model=newmodel)
                        # add term to medium ODE
                        medexp = add_diffusive_term(medexp, diffconst,f'Values[{oname}]',f'Values[{mediumode}]')
                        # add term to target ODE
                        odexpr = add_diffusive_term(tode.loc[oname].at['expression'], diffconst,f'Values[{mediumode}]', f'Values[{oname}]')
                        set_parameters(mediumode, exact=True, type='ode', expression=medexp, model=newmodel)
                        set_parameters(oname, exact=True, type='ode', expression=odexpr, model=newmodel)
                if( args.network ):
                    for link in links:
                        suffa = f'{link[0]}'
                        oaname = f'{ode}_{suffa}'
                        suffb = f'{link[1]}'
                        obname = f'{ode}_{suffb}'
                        # get ode a to get expression
                        aode = get_parameters(oaname, exact=True, model=newmodel)
                        # get ode b to get expression
                        bode = get_parameters(obname, exact=True, model=newmodel)
                        if( linktype=='d' ):
                            if digraph:
                                # add term to ODE a
                                odeaexpr = add_irr_diffusive_term(aode.loc[oaname].at['expression'], diffconst,'-',f'Values[{oaname}]')
                                # add term to ODE b
                                odebexpr = add_irr_diffusive_term(bode.loc[obname].at['expression'], diffconst,'+',f'Values[{oaname}]')
                            else:
                                # add term to ODE a
                                odeaexpr = add_diffusive_term(aode.loc[oaname].at['expression'], diffconst, f'Values[{obname}]', f'Values[{oaname}]')
                                # add term to ODE b
                                odebexpr = add_diffusive_term(bode.loc[obname].at['expression'], diffconst, f'Values[{oaname}]', f'Values[{obname}]')
                                # we update oaname here because it is not affected in the other type of connections
                                set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                        elif( linktype=='s' ):
                            # add a new ODE to represent the proportion of bound post-synaptic receptor
                            brname = f'br_{ode}_{suffa},{suffb}'
                            brexp = f'( 1 / Values[{syntaur}] - 1 / Values[{syntaud}] ) * ( 1 - Values[{brname}] ) / ( 1 + exp( Values[{synv0}] - Values[{oaname}] ) ) -  Values[{brname}] / Values[{syntaud}]'
                            add_parameter(brname, type='ode', expression=brexp, initial_value=0.5, model=newmodel)
                            # add a synaptic maximum conductance parameter
                            syngc = f'g_c_{ode}_{suffa},{suffb}_synapse'
                            add_parameter(syngc, type='fixed', initial_value=gcinit, model=newmodel)
                            # add a term to the postsynaptic ode corresponding to the voltage that is proportional to the bound receptor
                            odebexpr = bode.loc[obname].at['expression'] + f' - Values[{syngc}] * Values[{brname}] * ( Values[{synvsyn}] - Values[{oaname}] )'
                        # obname is affected by all types of connection so we can only update it here, after if/elif statements
                        set_parameters(obname, exact=True, expression=odebexpr, model=newmodel)
            elif( dim == 2 ):
                if(args.add_medium and linktype=='d'):
                    # we first need to add the global quantity for the medium
                    mediumode = f'{ode}_medium'
                    medexp = ''
                    add_parameter(mediumode, type='ode', expression=medexp, initial_value=mparams.loc[ode].at['initial_value'], model=newmodel)
                for r in range(gridr):
                    for c in range(gridc):
                        suffa = f'{r+1},{c+1}'
                        oaname = f'{ode}_{suffa}'
                        if(args.add_medium and linktype=='d'):
                            # add term to medium ODE
                            medexp = add_diffusive_term( medexp, diffconst, f'Values[{oaname}]', f'Values[{mediumode}]' )
                            set_parameters(mediumode, exact=True, type='ode', expression=medexp, model=newmodel)
                            # get ode to get expression
                            aode = get_parameters(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Values[{mediumode}]', f'Values[{oaname}]' )
                            set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                        if( c+1 < gridc ):
                            suffb = f'{r+1},{c+2}'
                            obname = f'{ode}_{suffb}'
                            # get ode to get expression
                            aode = get_parameters(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Values[{obname}]', f'Values[{oaname}]')
                            set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            # get ode to get expression
                            bode = get_parameters(obname, exact=True, model=newmodel)
                            # add term to target ODE
                            odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Values[{oaname}]', f'Values[{obname}]')
                            set_parameters(obname, exact=True, expression=odebexpr, model=newmodel)
                        if( r+1 < gridr ):
                            suffb = f'{r+2},{c+1}'
                            obname = f'{ode}_{suffb}'
                            # get ode to get expression
                            aode = get_parameters(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Values[{obname}]', f'Values[{oaname}]')
                            set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            # get ode to get expression
                            bode = get_parameters(obname, exact=True, model=newmodel)
                            # add term to target ODE
                            odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Values[{oaname}]', f'Values[{obname}]')
                            set_parameters(obname, exact=True, expression=odebexpr, model=newmodel)
            elif( dim == 3 ):
                if(args.add_medium and linktype=='d'):
                    # we first need to add the global quantity for the medium
                    mediumode = f'{ode}_medium'
                    medexp = ''
                    add_parameter(mediumode, type='ode', expression=medexp, initial_value=mparams.loc[ode].at['initial_value'], model=newmodel)
                for r in range(gridr):
                    for c in range(gridc):
                        for l in range(gridl):
                            suffa = f'{r+1},{c+1},{l+1}'
                            oaname = f'{ode}_{suffa}'
                            if(args.add_medium and linktype=='d'):
                                # add term to medium ODE
                                medexp = add_diffusive_term( medexp, diffconst, f'Values[{oaname}]', f'Values[{mediumode}]' )
                                set_parameters(mediumode, exact=True, type='ode', expression=medexp, model=newmodel)
                                # get ode to get expression
                                aode = get_parameters(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Values[{mediumode}]', f'Values[{oaname}]' )
                                set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            if( c+1 < gridc ):
                                suffb = f'{r+1},{c+2},{l+1}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_parameters(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Values[{obname}]', f'Values[{oaname}]')
                                set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_parameters(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Values[{oaname}]', f'Values[{obname}]')
                                set_parameters(obname, exact=True, expression=odebexpr, model=newmodel)
                            if( r+1 < gridr ):
                                suffb = f'{r+2},{c+1},{l+1}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_parameters(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Values[{obname}]', f'Values[{oaname}]')
                                set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_parameters(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Values[{oaname}]', f'Values[{obname}]')
                                set_parameters(obname, exact=True, expression=odebexpr, model=newmodel)
                            if( l+1 < gridl ):
                                suffb = f'{r+1},{c+1},{l+2}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_parameters(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Values[{obname}]', f'Values[{oaname}]')
                                set_parameters(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_parameters(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Values[{oaname}]', f'Values[{obname}]')
                                set_parameters(obname, exact=True, expression=odebexpr, model=newmodel)
            else:
                # insanity error
                print('ERROR: this should not happen, dim is not 1,2 or 3. Contact developer!')
                exit()
        # check if the ODE is a species
        elif( (mspecs is not None) and (ode in mspecs.index) ):
            if( mspecs.loc[ode].at['type'] != 'ode' ):
                print(f'ERROR: {ode} is a species but it is not of type ODE')
                continue
            # add medium unit if needed
            if(args.add_medium and linktype=='d'):
                # add the new medium species
                mediumode = f'{ode}_medium'
                medexp = ''
                add_species(mediumode, compartment_name=medium_name, type='ode', expression=medexp, initial_concentration=mspecs.loc[ode].at['initial_concentration'], model=newmodel)
            if( dim == 1):
                # add coupling between unit and the medium
                if(args.add_medium and linktype=='d'):
                    for r in range(gridr):
                        # name of ode in this unit
                        suffa = f'{r+1}'
                        oname = f'{ode}_{suffa}'
                        # add term to medium ODE
                        medexp = add_diffusive_term( medexp, diffconst, f'[{oname}]', f'[{mediumode}]')
                        set_species(mediumode, exact=True, expression=medexp, model=newmodel)
                        # get target ode to get expression
                        tode = get_species(oname, exact=True, model=newmodel)
                        # add term to target ODE
                        odexpr = add_diffusive_term( tode.loc[oname].at['expression'], diffconst, f'[{mediumode}]', f'[{oname}]' )
                        set_species(oname, exact=True, expression=odexpr, model=newmodel)
                if( args.network ):
                    for link in links:
                        suffa = f'{link[0]}'
                        oaname = f'{ode}_{suffa}'
                        suffb = f'{link[1]}'
                        obname = f'{ode}_{suffb}'
                        # get ode expressions from a and b
                        aode = get_species(oaname, exact=True, model=newmodel)
                        bode = get_species(obname, exact=True, model=newmodel)
                        if( linktype=='d' ):
                            if digraph:
                                # add term to ODE a
                                odeaexpr = add_irr_diffusive_term(aode.loc[oaname].at['expression'], diffconst,'-',f'[{oaname}]')
                                # add term to ODE b
                                odebexpr = add_irr_diffusive_term(bode.loc[obname].at['expression'], diffconst,'+',f'[{oaname}]')
                            else:
                                # add term to ODE a
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{obname}]', f'[{oaname}]')
                                # add term to ODE b
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'[{oaname}]', f'[{obname}]')
                            # we update oaname species here since it won't be modified in other types of connection
                            set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                        elif( linktype=='s' ):
                            # add a new ODE to represent the proportion of bound post-synaptic receptor
                            brname = f'br_{ode}_{suffa},{suffb}'
                            brexp = f'( 1 / Values[{syntaur}] - 1 / Values[{syntaud}] ) * ( 1 - Values[{brname}] ) / ( 1 + exp( Values[{synv0}] - [{oaname}] ) ) -  Values[{brname}] / Values[{syntaud}]'
                            add_parameter(brname, type='ode', expression=brexp, initial_value=0.5, model=newmodel)
                            # add a synaptic maximum conductance parameter
                            syngc = f'g_c_{ode}_{suffa},{suffb}_synapse'
                            add_parameter(syngc, type='fixed', initial_value=gcinit, model=newmodel)
                            # add a term to the postsynaptic ode corresponding to the voltage that is proportional to the bound receptor
                            odebexpr = bode.loc[obname].at['expression'] + f' - Values[{syngc}] * Values[{brname}] * ( Values[{synvsyn}] - [{oaname}] )'
                        # update species obname here as it was changed by all types
                        set_species(obname, exact=True, expression=odebexpr, model=newmodel)
            elif( dim == 2 ):
                for r in range(gridr):
                    for c in range(gridc):
                        suffa = f'{r+1},{c+1}'
                        oaname = f'{ode}_{suffa}'
                        if(args.add_medium and linktype=='d'):
                            # add term to medium ODE
                            medexp = add_diffusive_term( medexp, diffconst, f'[{oaname}]', f'[{mediumode}]')
                            set_species(mediumode, exact=True, expression=medexp, model=newmodel)
                            # get ode to get expression
                            aode = get_species(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{mediumode}]', f'[{oaname}]' )
                            set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                        if( c+1 < gridc ):
                            suffb = f'{r+1},{c+2}'
                            obname = f'{ode}_{suffb}'
                            # get ode to get expression
                            aode = get_species(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{obname}]', f'[{oaname}]')
                            set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            # get ode to get expression
                            bode = get_species(obname, exact=True, model=newmodel)
                            # add term to target ODE
                            odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'[{oaname}]', f'[{obname}]')
                            set_species(obname, exact=True, expression=odebexpr, model=newmodel)
                        if( r+1 < gridr ):
                            suffb = f'{r+2},{c+1}'
                            obname = f'{ode}_{suffb}'
                            # get ode to get expression
                            aode = get_species(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{obname}]', f'[{oaname}]')
                            set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            # get ode to get expression
                            bode = get_species(obname, exact=True, model=newmodel)
                            # add term to target ODE
                            odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'[{oaname}]', f'[{obname}]')
                            set_species(obname, exact=True, expression=odebexpr, model=newmodel)
            elif( dim == 3 ):
                for r in range(gridr):
                    for c in range(gridc):
                        for l in range(gridl):
                            suffa = f'{r+1},{c+1},{l+1}'
                            oaname = f'{ode}_{suffa}'
                            if(args.add_medium and linktype=='d'):
                                # add term to medium ODE
                                medexp = add_diffusive_term( medexp, diffconst, f'[{oname}]', f'[{mediumode}]')
                                set_species(mediumode, exact=True, expression=medexp, model=newmodel)
                                # get ode to get expression
                                aode = get_species(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaxpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{mediumode}]', f'[{oname}]' )
                                set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            if( c+1 < gridc ):
                                suffb = f'{r+1},{c+2},{l+1}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_species(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{obname}]', f'[{oaname}]')
                                set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_species(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'[{oaname}]', f'[{obname}]')
                                set_species(obname, exact=True, expression=odebexpr, model=newmodel)
                            if( r+1 < gridr ):
                                suffb = f'{r+2},{c+1},{l+1}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_species(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{obname}]', f'[{oaname}]')
                                set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_species(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'[{oaname}]', f'[{obname}]')
                                set_species(obname, exact=True, expression=odebexpr, model=newmodel)
                            if( l+1 < gridl ):
                                suffb = f'{r+1},{c+1},{l+2}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_species(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'[{obname}]', f'[{oaname}]')
                                set_species(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_species(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'[{oaname}]', f'[{obname}]')
                                set_species(obname, exact=True, expression=odebexpr, model=newmodel)
            else:
                # insanity error
                print('ERROR: this should not happen, dim is not 1,2 or 3. Contact developer!')
                exit()

        # check if the ODE is a compartment
        elif( (mcomps is not None) and (ode in mcomps.index) ):
            if( mcomps.loc[ode].at['type'] != 'ode' ):
                print(f'ERROR: {ode} is a compartment but it is not of type ODE')
                exit()
            if(linktype=='d'):
                print(f'ERROR: {ode} is a compartment ODE, but compartments cannot have synaptic links')
                exit()
            if( dim == 1):
                # for compartments we do nothing about the medium...
                # let's just work on the network
                if( args.network ):
                    for link in links:
                        suffa = f'{link[0]}'
                        oaname = f'{ode}_{suffa}'
                        suffb = f'{link[1]}'
                        obname = f'{ode}_{suffb}'
                        # get ode a to get expression
                        aode = get_compartments(oaname, exact=True, model=newmodel)
                        # get ode b to get expression
                        bode = get_compartments(obname, exact=True, model=newmodel)
                        if digraph:
                            # add term to ODE a
                            odeaexpr = add_irr_diffusive_term(aode.loc[oaname].at['expression'], diffconst,'-',f'Compartments[{oaname}].Volume')
                            # add term to ODE b
                            odebexpr = add_irr_diffusive_term(bode.loc[obname].at['expression'], diffconst,'+',f'Compartments[{oaname}].Volume')
                        else:
                            # add term to ODE a
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Compartments[{obname}].Volume', f'Compartments[{oaname}].Volume')
                            # add term to ODE b
                            odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Compartments[{oaname}].Volume', f'Compartments[{obname}].Volume')
                        set_compartments(oaname, exact=True, expression=odeaexpr, model=newmodel)
                        set_compartments(obname, exact=True, expression=odebexpr, model=newmodel)
            elif( dim == 2 ):
                for r in range(gridr):
                    for c in range(gridc):
                        suffa = f'{r+1},{c+1}'
                        oaname = f'{ode}_{suffa}'
                        if( c+1 < gridc ):
                            suffb = f'{r+1},{c+2}'
                            obname = f'{ode}_{suffb}'
                            # get ode to get expression
                            aode = get_compartments(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Compartments[{obname}].Volume', f'Compartments[{oaname}].Volume')
                            set_compartment(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            # get ode to get expression
                            bode = get_compartments(obname, exact=True, model=newmodel)
                            # add term to target ODE
                            odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Compartments[{oaname}].Volume', f'Compartments[{obname}].Volume')
                            set_compartment(obname, exact=True, expression=odebexpr, model=newmodel)
                        if( r+1 < gridr ):
                            suffb = f'{r+2},{c+1}'
                            obname = f'{ode}_{suffb}'
                            # get ode to get expression
                            aode = get_compartments(oaname, exact=True, model=newmodel)
                            # add term to target ODE
                            odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Compartments[{obname}].Volume', f'Compartments[{oaname}].Volume')
                            set_compartment(oaname, exact=True, expression=odeaexpr, model=newmodel)
                            # get ode to get expression
                            bode = get_compartments(obname, exact=True, model=newmodel)
                            # add term to target ODE
                            odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Compartments[{oaname}].Volume', f'Compartments[{obname}].Volume')
                            set_compartment(obname, exact=True, expression=odebexpr, model=newmodel)
            elif( dim == 3 ):
                for r in range(gridr):
                    for c in range(gridc):
                        for l in range(gridl):
                            suffa = f'{r+1},{c+1},{l+1}'
                            oaname = f'{ode}_{suffa}'
                            if( c+1 < gridc ):
                                suffb = f'{r+1},{c+2},{l+1}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_compartments(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Compartments[{obname}].Volume', f'Compartments[{oaname}].Volume')
                                set_compartment(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_compartments(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Compartments[{oaname}].Volume', f'Compartments[{obname}].Volume')
                                set_compartment(obname, exact=True, expression=odebexpr, model=newmodel)
                            if( r+1 < gridr ):
                                suffb = f'{r+2},{c+1},{l+1}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_compartments(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Compartments[{obname}].Volume', f'Compartments[{oaname}].Volume')
                                set_compartment(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_compartments(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Compartments[{oaname}].Volume', f'Compartments[{obname}].Volume')
                                set_compartment(obname, exact=True, expression=odebexpr, model=newmodel)
                            if( l+1 < gridl ):
                                suffb = f'{r+1},{c+1},{l+2}'
                                obname = f'{ode}_{suffb}'
                                # get ode to get expression
                                aode = get_compartments(oaname, exact=True, model=newmodel)
                                # add term to target ODE
                                odeaexpr = add_diffusive_term( aode.loc[oaname].at['expression'], diffconst, f'Compartments[{obname}].Volume', f'Compartments[{oaname}].Volume')
                                set_compartment(oaname, exact=True, expression=odeaexpr, model=newmodel)
                                # get ode to get expression
                                bode = get_compartments(obname, exact=True, model=newmodel)
                                # add term to target ODE
                                odebexpr = add_diffusive_term( bode.loc[obname].at['expression'], diffconst, f'Compartments[{oaname}].Volume', f'Compartments[{obname}].Volume')
                                set_compartment(obname, exact=True, expression=odebexpr, model=newmodel)
            else:
                # insanity error
                print('ERROR: this should not happen, dim is not 1,2 or 3. Contact developer!')
                exit()
        # not an entity in this model
        else:
            print(f'ERROR: {ode} is not a valid model entity')
            exit()


#####
# 12. set task parameters
#####

if( not args.ignore_tasks):
    # time course
    tc = get_task_settings('Time-Course', basic_only=False, model=seedmodel)
    set_task_settings('Time-Course', {'scheduled': tc['scheduled'], 'problem': tc['problem'], 'method': tc['method']},model=newmodel)

    # steady state
    ss = get_task_settings('Steady-State', basic_only=False, model=seedmodel)
    set_task_settings('Steady-State', {'scheduled': ss['scheduled'], 'update_model': ss['update_model'], 'problem': ss['problem'], 'method': ss['method']},model=newmodel)

    # MCA
    mca = get_task_settings('Metabolic Control Analysis', basic_only=False, model=seedmodel)
    set_task_settings('Metabolic Control Analysis', {'scheduled': mca['scheduled'], 'update_model': mca['update_model'], 'problem': mca['problem'], 'method': mca['method']},model=newmodel)

    # Lyapunov Exponents
    le = get_task_settings('Lyapunov Exponents', basic_only=False, model=seedmodel)
    set_task_settings('Lyapunov Exponents', {'scheduled': le['scheduled'], 'update_model': le['update_model'], 'problem': le['problem'], 'method': le['method']},model=newmodel)

    # Time Scale Separation Analysis
    tsa = get_task_settings('Time Scale Separation Analysis', basic_only=False, model=seedmodel)
    set_task_settings('Time Scale Separation Analysis', {'scheduled': tsa['scheduled'], 'update_model': tsa['update_model'], 'problem': tsa['problem'], 'method': tsa['method']},model=newmodel)

    # Cross section
    cs = get_task_settings('Cross Section', basic_only=False, model=seedmodel)
    if( cs['problem']['SingleVariable'] != ''):
        newv = fix_expression(cs['problem']['SingleVariable'], apdx1)
        print(f' Warning: the cross section task was updated to use {newv} as variable.')
        cs['problem']['SingleVariable'] = newv
        set_task_settings('Cross Section', {'scheduled': cs['scheduled'], 'update_model': cs['update_model'], 'problem': cs['problem'], 'method': cs['method']},model=newmodel)

    # Linear Noise Approximation
    lna = get_task_settings('Linear Noise Approximation', basic_only=False, model=seedmodel)
    set_task_settings('Linear Noise Approximation', {'scheduled': lna['scheduled'], 'update_model': lna['update_model'], 'problem': lna['problem'], 'method': lna['method']},model=newmodel)

    # Sensitivities
    sen = get_sensitivity_settings(model=seedmodel)
    seff = fix_expression(sen['effect'],apdx1)
    scau = fix_expression(sen['cause'],apdx1)
    ssec = fix_expression(sen['secondary_cause'],apdx1)
    if( (seff != sen['effect']) or (scau != sen['cause']) or (ssec != sen['secondary_cause']) ):
        print(f' Warning: sensitivies task is now using items of unit {apdx1}")')
        sen['effect'] = seff
        sen['cause'] = scau
        sen['secondary_cause'] = ssec
    set_sensitivity_settings(sen, model=newmodel)

    # Parameter scan
    ps = get_task_settings('Scan', basic_only=False, model=seedmodel)
    set_task_settings('Scan', {'scheduled': ps['scheduled'], 'update_model': ps['update_model'], 'problem': ps['problem'], 'method': ps['method']},model=newmodel)

    # we got the scanitems way earlier due to a bug in COPASI/BasiCO ...
    # when there are scan or random sampling items, we convert them to be those of the first unit
    srw = False
    for sit in scanitems:
        if( sit['type']=='parameter_set' ):
            print(f' Warning: a scan of parameter sets exists in the original model but was not included in the new model.')
        else:
            if( sit['type']=='scan' ):
                newit = fix_expression(sit['item'], apdx1)
                srw = True
                add_scan_item(model=newmodel, type=sit['type'], num_steps=sit['num_steps'], item=newit, log=sit['log'], min=sit['min'], max=sit['max'], use_values=sit['use_values'], values=sit['values'] )
            else:
                if( sit['type']=='random' ):
                    newit = fix_expression(sit['item'], apdx1)
                    srw = True
                    add_scan_item(model=newmodel, type=sit['type'], num_steps=sit['num_steps'], item=newit, log=sit['log'], min=sit['min'], max=sit['max'], distribution=sit['distribution'])
                else:
                    if( sit['type']=='repeat' ):
                        add_scan_item(model=newmodel, type=sit['type'], num_steps=sit['num_steps'])
                    else:
                        tp = sit['type']
                        print(f' Warning: This scan task includes an unknonw type {tp}, likely from a new version of COPASI. Please file an issue on Github.')
    if( srw ): print(' Warning: in Parameter scan task the scanned or sampled items were converted to those of the first unit only.')

    # Optimization
    # we translate the objective function and parameters to the first unit
    nopt = get_opt_settings(model=seedmodel)
    if( nopt['expression'] ):
        nopt['expression'] = fix_expression(nopt['expression'], apdx1)
        set_opt_settings(nopt,newmodel)
        # deal with paramters
        ops = get_opt_parameters(model=seedmodel)
        for p in ops.index:
            # rename the CN
            ops.loc[p, 'cn'] = fix_expression(ops.loc[p].at['cn'] ,apdx1)
            # rename the index
            newp = fix_expression(p,apdx1)
            ops.rename(index={p: newp}, inplace=True)
        set_opt_parameters(ops, model=newmodel)
        cst = get_opt_constraints(model=seedmodel)
        # deal with constraints
        for p in cst.index:
            # rename the CN
            cst.loc[p, 'cn'] = fix_expression(cst.loc[p].at['cn'] ,apdx1)
            # rename the index
            newp = fix_expression(p,apdx1)
            cst.rename(index={p: newp}, inplace=True)
        set_opt_constraints(cst, model=newmodel)
        print(' Warning: in Optimization task the objective function and the search parameters were converted to those of the first unit only.')

    # We won't do Parameter estimation but need to issue a warning if it was set
    exps = get_experiment_filenames(model=seedmodel)
    if( len(exps)>0 ):
        print(' Warning: Parameter Estimation task settings were not copied to the new model.')

    # We won't do Time Course Sensitivities but need to issue a warning if it was set
    tcs = get_task_settings( 'Time-Course Sensitivities', basic_only=False, model=seedmodel)
    if( tcs['scheduled'] ):
        print(' Warning: Time Course Sensitivities task settings were not copied to the new model.')


#TODO: what to do with reports?
#TODO: to do with plots?

#####
# 13. save model
#####

# save the new model
if( (ext.lower() == '.cps') and not args.sbml ):
    save_model(filename=newfilename, model=newmodel)
else:
    save_model(filename=newfilename, type='sbml', sbml_level=sbmll, sbml_version=sbmlv, model=newmodel)
if( not args.quiet ):
    print(f"created new model {newfilename} with {desc} of {seedmodelfile}\n")
